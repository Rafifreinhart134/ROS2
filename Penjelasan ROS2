1. Mengapa harus ada Launch File (.launch.py)?
Launch file adalah "manajer proyek" Anda. Jika di ESP32 Anda hanya punya satu void loop(), di robot besar Anda mungkin punya 50 node (sensor laser, kamera, penggerak roda, dll).

Fungsinya: Menjalankan banyak node sekaligus hanya dengan satu perintah terminal. Tanpa file ini, Anda harus membuka 50 terminal dan mengetik ros2 run... satu per satu.

Kenapa namanya generate_launch_description? Ini adalah fungsi standar yang dicari oleh sistem ROS2 saat Anda menjalankan perintah ros2 launch. Fungsi ini tidak dipanggil oleh node lain, melainkan oleh sistem operasi ROS2 untuk mengetahui daftar node apa saja yang harus dinyalakan.

Hubungannya dengan node: Di dalam file launch, Anda menuliskan executable='status_publisher'. Nama ini merujuk pada nama yang Anda daftarkan di setup.py. Jadi, file launch hanya bertugas "menekan tombol start" pada node-node tersebut.

2. Memahami setup.py
File ini adalah "buku daftar isi" paket Anda.

console_scripts: ROS2 tidak menjalankan file .py secara langsung seperti python3 file.py. ROS2 mencari "alias" atau nama panggilan. Di sini Anda mendaftarkan: nama_panggilan = folder.file:fungsi_utama. Itulah mengapa Anda bisa mengetik ros2 run ros2_python_nodes status_publisher.

data_files (bagian launch): Secara default, saat Anda melakukan colcon build, ROS2 hanya menyalin kode Python. File .launch.py berada di folder luar. Baris os.path.join(...) memerintahkan ROS2 untuk menyalin file launch tersebut ke folder sistem (install/) agar bisa ditemukan saat dipanggil.


3. Bagaimana Node Saling Terhubung? (Baris Kode Kuncinya)
Berbeda dengan ESP32 yang menggunakan if-else dalam satu file, ROS2 menggunakan DDS (Data Distribution Service) sebagai perantara. Mereka terhubung karena memiliki Nama Topik atau Nama Service yang sama.

Berikut baris kode yang menghubungkan mereka:
A. Komunikasi Topic (Publisher & Subscriber)
Di status_publisher.py:
self.create_publisher(String, 'robot_status', 10).
Kuncinya: Nama topik 'robot_status'. Node ini mengumumkan: "Saya akan mengirim data String ke saluran bernama 'robot_status'".

Di status_listener.py:
self.create_subscription(String, 'robot_status', self.callback, 10).
Kuncinya: Nama topik harus sama persis: 'robot_status'. Node ini berkata: "Saya mau mendengarkan saluran bernama 'robot_status'".

B. Komunikasi Service (Server & Client)
Di service_server.py:
self.create_service(SetBool, 'get_status', self.callback).
Kuncinya: Nama service 'get_status'. Server stand-by di jalur ini.

Di service_client.py:
self.create_client(SetBool, 'get_status').
Kuncinya: Client memanggil jalur yang sama yaitu 'get_status'.

Perbedaan Utama dengan ESP32
Jika di ESP32 Anda menulis:
if (sensor_read == HIGH) { digitalWrite(LED, HIGH); }

Di ROS2 Anda membaginya:
Node Sensor: Membaca sensor lalu mengirim (Publish) ke topik /sensor_data.
Node Logika: Mendengarkan (Subscribe) topik /sensor_data. Jika datanya HIGH, dia mengirim perintah (Publish atau Call Service) ke topik/service /led_control.
Node LED: Mendengarkan topik /led_control dan menyalakan lampu fisik.

Kenapa repot begitu? Agar jika Anda ingin mengganti sensor, Anda cukup mengganti satu node sensor saja tanpa menyentuh kode logika atau kode LED. Ini membuat sistem robot sangat fleksibel dan mudah diperbaiki.



kenapa di service dan subscription itu ada self.callback sedangkan publisher dan client tidak ada ?
self.create_subscription(String, 'robot_status', self.callback, 10)
self.create_publisher(String, 'robot_status', 10)

Perbedaan mendasar antara model komunikasi asinkron (menunggu) dan proaktif (memerintah) di ROS2.

Alasan utamanya adalah Subscriber dan Service Server bersifat "pasif" atau reaktif, sedangkan Publisher dan Client bersifat "aktif" atau proaktif.

Berikut penjelasan detailnya:
1. Kenapa Subscriber & Service Server butuh self.callback?
Kedua komponen ini tidak tahu kapan data atau permintaan akan datang. Mereka harus selalu siaga.

Subscriber: Dia hanya diam sampai ada data yang lewat di Topic. Begitu data datang, sistem ROS2 bertanya: "Apa yang harus saya lakukan dengan data ini?". Di sinilah callback (fungsi panggilan balik) berperan sebagai instruksi otomatis.
Service Server: Dia standby menunggu Client memanggil. Begitu ada "ketukan pintu" (request), dia menjalankan callback untuk memproses permintaan tersebut dan memberikan jawaban.
Logikanya: Callback seperti memasang alarm. Anda tidak tahu kapan alarm bunyi, tapi Anda sudah menentukan: "Jika bunyi, lakukan fungsi ini".

2. Kenapa Publisher & Client tidak punya self.callback yang sama?
Komponen ini adalah pihak yang memulai aksi, sehingga mereka memegang kendali penuh atas kapan kode dijalankan.

Publisher: Dialah yang memutuskan kapan mengirim data. Biasanya kita menggunakan Timer. Timer-lah yang memiliki callback untuk memicu fungsi publish(), bukan Publisher-nya sendiri.
Service Client: Dia yang mengirim permintaan (request). Dia tidak butuh callback untuk menerima permintaan karena dialah pembuatnya. Namun, perlu dicatat bahwa Client biasanya menggunakan fitur future atau async_call untuk menunggu jawaban agar program tidak membeku (freeze) saat menunggu server.

Perbandingan Sederhana:
Subscriber & Server: Seperti Pelayan Restoran. Dia tidak tahu kapan tamu datang. Dia butuh "instruksi tetap" (callback): "Jika tamu datang, berikan menu".
Publisher & Client: Seperti Tamu. Dia yang memutuskan kapan mau memesan. Dia tidak menunggu instruksi untuk memesan, dia langsung melakukan aksi call atau send.

Di mana baris penghubungnya?
Meskipun Publisher tidak punya callback internal, di dalam kode Anda:
Publisher: Digerakkan oleh self.create_timer(1.0, self.timer_callback). Timer inilah yang memanggil fungsi pengirim pesan secara rutin.
Subscriber: Terhubung langsung saat pembuatan: self.create_subscription(..., self.listener_callback, ...). Di sini self.listener_callback adalah perintah otomatis setiap ada pesan masuk.

Jadi, callback adalah cara ROS2 menangani kejadian yang tidak terduga waktunya (event-driven) agar CPU Anda tidak bekerja keras melakukan pengecekan if-else terus-menerus secara manual seperti pada beberapa pola pemrograman mikrokontroler tradisional.
